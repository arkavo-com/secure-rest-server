package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

)

func main() {
	var directory string
	flag.StringVar(&directory, "dir", ".", "directory to search for pb files")
	flag.Parse()
	filepathErr := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// ignore all files that have not been generated by pb
		if strings.HasSuffix(path, ".pb.go") == false {
			return nil
		}
		fmt.Println(path)
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("could not parse go file: %v", err)
		}
		// print ast for reference
		//ast.Print(fset, node)
		var v visitor
		// get package
		v.pkg = *node.Name
		// get struct name
		ast.Inspect(node, func(n ast.Node) bool {
			// Find StructType
			st, sn := isStructTypeDecl(n)
			if st != nil && strings.ToLower(strings.TrimRight(info.Name(), ".pb.go")) == strings.ToLower(sn) {
				v.pmName = sn
			}
			// Find const
			gd, ok := n.(*ast.GenDecl)
			if !ok || gd.Tok != token.CONST {
				return true
			}
			if gd.Lparen == token.NoPos {
				return true
			}
			for _, sp := range gd.Specs {
				vs, ok := sp.(*ast.ValueSpec)
				if !ok {
					continue
				}
				it, ok := vs.Type.(*ast.Ident)
				if !ok {
					continue
				}
				if strings.HasSuffix(it.Name, "_Action") {
					sp := strings.Split(vs.Names[0].Name, "_")
					v.pmActions = append(v.pmActions, sp[1])
				}
			}
			return true
		})
		// modify tags
		ast.Walk(v, node)
		// output file
		f, err := os.Create(path)
		if err != nil {
			return fmt.Errorf("could not open output file: %v", err)
		}
		defer f.Close()
		err = format.Node(f, fset, node)
		if err != nil {
			return fmt.Errorf("could not write output file: %v", err)
		}
		var exActions []ast.Expr
		for i, a := range v.pmActions {
			exActions = append(exActions, &ast.BasicLit{
				ValuePos: token.Pos(i),
				Kind:     token.STRING,
				Value:    strconv.Quote(a),
			})
		}
		v.pmFile = ast.File{
			Name: &v.pkg,
			Decls: []ast.Decl{
				&ast.GenDecl{
					Tok: token.VAR,
					Specs: []ast.Spec{
						&ast.TypeSpec{
							Name:   ast.NewIdent(v.pmName + "Permission"),
							Assign: 1,
							Type: &ast.CompositeLit{
								Type:   ast.NewIdent("Permission"),
								Lbrace: 1,
								Elts: []ast.Expr{
									&ast.KeyValueExpr{
										Key:   ast.NewIdent("Class"),
										Colon: 1,
										Value: &ast.BasicLit{
											ValuePos: 1,
											Kind:     token.STRING,
											Value:    strconv.Quote(v.pmName),
										},
									},
									&ast.KeyValueExpr{
										Key:   ast.NewIdent("Actions"),
										Colon: 1,
										Value: &ast.CompositeLit{
											Type: &ast.ArrayType{
												Lbrack: 1,
												Elt:    ast.NewIdent("string"),
											},
											Lbrace: 1,
											Elts:   exActions,
											Rbrace: 2,
										},
									},
								},
								Rbrace: 2,
							},
						},
					},
				},
			},
		}
		fset = token.NewFileSet()
		// .pm.go output file
		pmf, err := os.Create(strings.Replace(path, ".pb.", ".pm.", 1))
		defer pmf.Close()
		if err != nil {
			return fmt.Errorf("could not open output file: %v", err)
		}
		// print
		err = printer.Fprint(pmf, fset, &v.pmFile)
		if err != nil {
			log.Fatal(err)
		}
		return nil
	})
	if filepathErr != nil {
		log.Printf("could not correctly handle directory: %v", filepathErr)
	}
}

// define a visitor struct to handle every ast node
type visitor struct {
	pmFile    ast.File
	pmName    string
	pmActions []string
	pkg       ast.Ident
}

// Visit will find all fields in the code and add tags that are placed
// in the comment above the field as struct tags to the field
func (v visitor) Visit(n ast.Node) ast.Visitor {
	if n == nil {
		return nil
	}
	switch n.(type) {
	case *ast.Field:
		// comments after the field are stripped away by the grpc protoc-generator
		// therefore we need to check the lines above the field which are
		// contained in the commentgroup that is part of the field
		var commentAbove string
		// iterate through the sub-nodes of the field
		ast.Inspect(n, func(subn ast.Node) bool {
			// get the content of all comment groups in the field
			switch subd := subn.(type) {
			case *ast.CommentGroup:
				commentAbove = commentAbove + subd.Text()
			}
			return true
		})
		if commentAbove == "" || strings.TrimSpace(commentAbove) == "" {
			return v
		}
		// find all tag expressions in the comment
		tagComment := strings.Trim(tagExp.FindString(commentAbove), "`")
		if tagComment == "" {
			return v
		}
		//fmt.Println(tagComment)
		additionalTags := strings.Split(tagComment, " ")
		// tags are stored as subnodes of type ast.BasicLit
		ast.Inspect(n, func(subn ast.Node) bool {
			switch subd := subn.(type) {
			case *ast.BasicLit:
				// remove the ticks from the current value
				existingTagValue := strings.Trim(subd.Value, "`")
				// add additional tags to the struct
				if existingTagValue == "" {
					subd.Value = fmt.Sprintf("`%s`", strings.Join(additionalTags, " "))
					return true
				}
				// add or replace additional tags
				existingTags := strings.Split(existingTagValue, " ")
				for _, additionalTag := range additionalTags {
					additionalTagParts := strings.Split(additionalTag, ":")
					foundIndex := -1
					for index, existingTag := range existingTags {
						existingTagParts := strings.Split(existingTag, ":")
						if fmt.Sprintf("%v:", additionalTagParts[0]) == fmt.Sprintf("%v:", existingTagParts[0]) {
							foundIndex = index
							break
						}
					}
					if foundIndex > -1 {
						existingTags = append(existingTags[:foundIndex], existingTags[foundIndex+1:]...)
					}
				}
				mergedTags := append(existingTags, additionalTags...)
				subd.Value = fmt.Sprintf("`%s`", strings.Join(mergedTags, " "))
			}
			return true
		})
	}
	return v
}

// tagExp will find tag expressions in the comment
var tagExp = regexp.MustCompile("`[a-z]*:.*`")

// isStructTypeDecl checks whether n is a struct declaration.
// It either returns a non-nil StructType and its name, or zero values.
func isStructTypeDecl(n ast.Node) (st *ast.StructType, name string) {
	gd, ok := n.(*ast.GenDecl)
	if !ok || gd.Tok != token.TYPE {
		return nil, ""
	}
	if gd.Lparen > 0 {
		return nil, ""
	}
	if len(gd.Specs) != 1 {
		return nil, ""
	}
	ts, ok := gd.Specs[0].(*ast.TypeSpec)
	if !ok {
		return nil, ""
	}
	st, ok = ts.Type.(*ast.StructType)
	if !ok {
		return nil, ""
	}
	return st, ts.Name.Name
}
